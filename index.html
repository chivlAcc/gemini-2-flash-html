<!DOCTYPE html>
<html lang="id">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Chatbot Lokal dengan Virtual Keyboard</title>
  <style>
    body {
      margin: 0;
      font-family: sans-serif;
      display: flex;
      flex-direction: column;
      height: 100vh;
      overflow: hidden;
    }
    button { cursor: pointer; }

    #controls {
      padding: .5rem;
      background: #f5f5f5;
      display: flex;
      justify-content: space-between;
      border-bottom: 1px solid #ececec;
      flex-shrink: 0;
    }
    #controls button { background: none; border: none; font-size: 1rem; }

    #api-container {
      display: none; /* Initially hidden */
      padding: .5rem;
      background: #fafafa;
      border-bottom: 1px solid #ececec;
      flex-shrink: 0;
      align-items: center; /* Align items vertically */
    }
    #api-container input {
      flex: 1;
      padding: .25rem;
      font-size: .9rem;
      border: 1px solid #ccc;
      border-radius: 4px;
      margin-right: .5rem;
    }
    #api-container button {
      padding: .25rem .5rem;
      font-size: .9rem;
      border: 1px solid #ccc;
      border-radius: 4px;
      background: #eee;
      margin-left: .25rem;
    }

    #content-wrap {
      display: flex;
      flex: 1;
      overflow: hidden;
    }
    #chat-section {
      flex: 1;
      display: flex;
      flex-direction: column;
      border-right: 1px solid #ececec;
      overflow: hidden;
    }

    #chat-container {
      flex: 1;
      padding: .5rem;
      overflow-y: auto;
    }
    .message { margin-bottom: .5rem; line-height: 1.4; word-wrap: break-word; }
    .user { text-align: right; color: #0066cc; }
    .bot  { text-align: left;  color: #333; background-color: #f0f0f0; padding: 5px 8px; border-radius: 8px; display: inline-block; max-width: 90%; }

    #error-box {
      display: none;
      color: #d9534f;
      background-color: #f2dede;
      padding: .5rem;
      flex-shrink: 0;
      border-top: 1px solid #e4b9b9;
      font-size: 0.9rem;
    }

    #input-form {
      display: flex;
      padding: .5rem;
      background: #f5f5f5;
      border-top: 1px solid #ececec;
      flex-shrink: 0;
    }
    #input-form input {
      flex: 1;
      padding: .25rem .5rem; /* Adjusted padding */
      font-size: .9rem;
      border: 1px solid #ccc;
      border-radius: 4px;
    }
    #input-form button[type="submit"] { display: none; } /* Hide the default submit button */

    /* ===== Keyboard Config Vars ===== */
    :root {
      --key-w: 2rem;
      --key-h: 3rem;
      --char-font: clamp(.7rem, 1.2vw, 1rem);
      --special-key-font: clamp(.8rem, 1.5vw, 1.1rem);
      --scrollbar-width: 10px;
    }

    #keyboard-container {
      display: flex;
      flex-direction: row;
      width: calc(var(--key-w) * 2 + var(--key-w) + 0.4rem + var(--scrollbar-width)); /* 2 char keys + 1 special key + gaps + scrollbar */
      max-width: 160px;
      background: #f9f9f9;
      flex-shrink: 0;
      height: calc(100vh - 2.5rem - 1px - 2.5rem - 1px); /* Adjust based on header/footer heights */
      overflow: hidden; /* Prevent overall container scroll */
    }

    #special-keys {
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      align-items: center;
      width: var(--key-w); /* Fixed width for special keys column */
      height: 100%;
      flex-shrink: 0;
    }
    #special-keys button.key {
      flex: 1;
      writing-mode: vertical-rl;
      text-orientation: mixed;
      font-size: var(--special-key-font);
      border: 1px solid #ccc;
      background: white;
      width: 100%;
      margin: 0.1rem 0; /* Small vertical gap */
      display: flex; /* Ensure centering */
      align-items: center;
      justify-content: center;
      padding: 0 .2rem; /* Padding for vertical text */
      box-sizing: border-box;
    }
    #special-keys button.key:first-child { margin-top: 0.2rem; } /* Align top with grid */
    #special-keys button.key:last-child { margin-bottom: 0.2rem; } /* Align bottom with grid */


    #keyboard {
      display: grid;
      grid-template-columns: repeat(2, var(--key-w));
      grid-auto-rows: var(--key-h);
      gap: .2rem;
      overflow-y: auto;
      overflow-x: hidden;
      height: 100%; /* Make keyboard scrollable within its container */
      width: calc(var(--key-w) * 2 + 0.2rem + var(--scrollbar-width)); /* Width for 2 columns + gap + scrollbar */
      padding: 0.2rem 0 0.2rem 0.2rem; /* Padding to match grid gap visually */
      box-sizing: border-box;
      scrollbar-width: thin; /* For Firefox */
      scrollbar-color: #888 #f1f1f1; /* For Firefox */
    }
    #keyboard::-webkit-scrollbar {
      width: var(--scrollbar-width);
    }
    #keyboard::-webkit-scrollbar-button {
      display: none;
    }
    #keyboard::-webkit-scrollbar-thumb {
      background: #888;
      border-radius: 5px;
    }
    #keyboard::-webkit-scrollbar-track {
      background: #f1f1f1;
    }
    button.key {
      width: var(--key-w);
      height: var(--key-h);
      font-size: var(--char-font);
      display: flex;
      align-items: center;
      justify-content: center;
      border: 1px solid #ccc;
      background: white;
      user-select: none;
      touch-action: manipulation;
      box-sizing: border-box;
    }
  </style>
</head>
<body>
  <div id="controls">
    <button id="toggle-api-btn">API</button>
    <button id="reset-btn">Reset</button>
  </div>
  <div id="api-container">
    <input type="text" id="api-key" placeholder="API Key" />
    <button id="paste-btn">Paste</button>
    <button id="clear-btn">Clear</button>
  </div>
  <div id="content-wrap">
    <div id="chat-section">
      <div id="chat-container"></div>
      <div id="error-box"></div>
      <form id="input-form">
        <input type="text" id="user-input" placeholder="Tulis pesan..." autocomplete="off" required />
        <button type="submit"></button> <!-- Hidden, used for Enter key submit -->
      </form>
    </div>
    <div id="keyboard-container">
      <div id="special-keys"></div>
      <div id="keyboard"></div>
    </div>
  </div>
  <script>
    const chatContainer = document.getElementById('chat-container');
    const inputForm = document.getElementById('input-form');
    const userInput = document.getElementById('user-input');
    const errorBox = document.getElementById('error-box');
    const apiKeyInput = document.getElementById('api-key');
    const toggleApiBtn = document.getElementById('toggle-api-btn');
    const apiContainer = document.getElementById('api-container');
    const pasteBtn = document.getElementById('paste-btn');
    const clearBtn = document.getElementById('clear-btn');
    const resetBtn = document.getElementById('reset-btn');
    const dbName = 'chatbotDB';
    const storeName = 'messages';
    let db; // Database instance

    // --- IndexedDB Functions ---
    function openDB() {
      return new Promise((resolve, reject) => {
        const request = indexedDB.open(dbName, 1);

        request.onupgradeneeded = function(event) {
          const dbInstance = event.target.result;
          if (!dbInstance.objectStoreNames.contains(storeName)) {
            dbInstance.createObjectStore(storeName, { keyPath: 'id', autoIncrement: true });
          }
        };

        request.onerror = function(event) {
          showError('Database error: ' + event.target.errorCode);
          reject('Database error: ' + event.target.errorCode);
        };

        request.onsuccess = function(event) {
          db = event.target.result; // Assign db instance globally
          console.log("Database opened successfully.");
          resolve(db);
        };
      });
    }

    function addMessageToDB(message) {
      return new Promise((resolve, reject) => {
        if (!db) {
            console.error("DB not initialized for adding message.");
            return reject("DB not initialized");
        }
        const transaction = db.transaction([storeName], 'readwrite');
        const store = transaction.objectStore(storeName);
        const request = store.add(message);

        request.onsuccess = function() {
          console.log("Message added to DB:", message);
          resolve();
        };

        request.onerror = function(event) {
          showError('Error saving message: ' + event.target.error);
          console.error('Error saving message:', event.target.error);
          reject(event.target.error);
        };
      });
    }

    function loadMessagesFromDB() {
        return new Promise((resolve, reject) => {
            if (!db) {
                console.error("DB not initialized for loading messages.");
                return reject("DB not initialized");
            }
            const transaction = db.transaction([storeName], 'readonly');
            const store = transaction.objectStore(storeName);
            const request = store.getAll();

            request.onsuccess = function() {
                console.log("Messages loaded from DB:", request.result);
                resolve(request.result);
            };

            request.onerror = function(event) {
                showError('Error loading messages: ' + event.target.error);
                console.error('Error loading messages:', event.target.error);
                reject(event.target.error);
            };
        });
    }

     function clearMessagesDB() {
        return new Promise((resolve, reject) => {
             if (!db) {
                console.error("DB not initialized for clearing messages.");
                return reject("DB not initialized");
            }
            const transaction = db.transaction([storeName], 'readwrite');
            const store = transaction.objectStore(storeName);
            const request = store.clear();

            request.onsuccess = function() {
                console.log("Message store cleared.");
                resolve();
            };

            request.onerror = function(event) {
                showError('Error clearing messages: ' + event.target.error);
                console.error('Error clearing messages:', event.target.error);
                reject(event.target.error);
            };
        });
    }

    // --- Chat Functions ---
    function displayMessage(msg, cls) {
      const d = document.createElement('div');
      d.className = 'message ' + cls;
      // Simple text display, consider using textContent for security if msg isn't HTML
      d.textContent = msg;
      chatContainer.appendChild(d);
      // Scroll to the bottom
      chatContainer.scrollTop = chatContainer.scrollHeight;
    }

    function showError(e) {
        errorBox.textContent = e;
        errorBox.style.display = 'block';
        // Optional: auto-hide error after some time
        // setTimeout(hideError, 5000);
    }
    function hideError() {
        errorBox.style.display = 'none';
        errorBox.textContent = '';
    }

    function clearApiKey() {
        apiKeyInput.value = '';
        localStorage.removeItem('chatbot-api-key');
        console.log("API Key cleared.");
    }

    function saveApiKey(key) {
        localStorage.setItem('chatbot-api-key', key);
        console.log("API Key saved.");
    }

    // --- Event Listeners ---
    inputForm.addEventListener('submit', async (e) => {
      e.preventDefault();
      hideError();
      const userText = userInput.value.trim();
      if (!userText) return;

      const apiKey = apiKeyInput.value.trim();
      if (!apiKey) {
        showError('Error: API Key belum dimasukkan. Silakan klik tombol "API" di atas.');
        return;
      }
      saveApiKey(apiKey); // Save key on successful use attempt

      // Display and save user message
      displayMessage(userText, 'user');
      try {
          await addMessageToDB({ text: userText, sender: 'user', timestamp: new Date() });
      } catch (dbError) {
          showError("Gagal menyimpan pesan Anda ke database.");
          // Decide if you want to proceed without saving or stop
          // return;
      }

      const originalInput = userText; // Store original input before clearing
      userInput.value = ''; // Clear input field immediately

      // Send to API
      try {
        const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${encodeURIComponent(apiKey)}`;
        const requestBody = {
          contents: [{
            parts: [{ "text": originalInput }] // Use the stored original input
          }]
        };

        console.log("Sending to API:", apiUrl, JSON.stringify(requestBody));

        const response = await fetch(apiUrl, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify(requestBody)
        });

        console.log("API Response Status:", response.status, response.statusText);

        if (!response.ok) {
          const errorData = await response.text(); // Try to get error details
          console.error("API Error Response:", errorData);
          throw new Error(`API Error ${response.status} ${response.statusText}: ${errorData}`);
        }

        const data = await response.json();
        console.log("API Response Data:", data);

        // Extract bot reply - Adjust based on actual Gemini API response structure
        const botReply = data?.candidates?.[0]?.content?.parts?.[0]?.text || 'Maaf, saya tidak bisa memproses permintaan itu saat ini.';

        // Display and save bot message
        displayMessage(botReply, 'bot');
         try {
             await addMessageToDB({ text: botReply, sender: 'bot', timestamp: new Date() });
         } catch (dbError) {
             showError("Gagal menyimpan respons bot ke database.");
             // Continue anyway, message is already displayed
         }

      } catch (err) {
        console.error('Fetch error:', err);
        showError('Error saat menghubungi API: ' + err.message);
        // Optionally display a generic bot error message
        // displayMessage("Maaf, terjadi kesalahan.", 'bot');
      }
    });

    toggleApiBtn.onclick = () => {
        const isHidden = apiContainer.style.display === 'none' || apiContainer.style.display === '';
        apiContainer.style.display = isHidden ? 'flex' : 'none';
        console.log("API container toggled:", !isHidden);
    };

    pasteBtn.onclick = async () => {
        hideError();
        try {
            const text = await navigator.clipboard.readText();
            apiKeyInput.value = text;
            saveApiKey(text); // Save when pasted
            console.log("API Key pasted from clipboard.");
        } catch (err) {
            console.error('Clipboard paste error:', err);
            showError('Gagal membaca dari clipboard. Pastikan izin diberikan.');
        }
    };

    clearBtn.onclick = () => {
        clearApiKey();
        hideError(); // Clear any previous errors
    };

    resetBtn.onclick = async function() {
        hideError();
        if (confirm("Apakah Anda yakin ingin menghapus semua riwayat percakapan?")) {
            try {
                await clearMessagesDB();
                chatContainer.innerHTML = ''; // Clear chat display
                console.log("Chat history cleared.");
            } catch(err) {
                showError("Gagal menghapus riwayat: " + err);
            }
        }
    };

    // --- Virtual Keyboard Logic ---
    (function() {
      const specialKeys = ['backspace', 'space', 'enter'];
      // Compact character pairs for vertical space
      const pairs = [
        ['a', ':'], ['b', ']'], ['c', '['], ['d', ';'], ['e', '='],
        ['f', '`'], ['g', '"'], ['h', '~'], ['i', '|'], ['j', '<'],
        ['k', "'"], ['l', '>'], ['m', '{'], ['n', '°'], ['o', '/'],
        ['p', '≈'], ['q', '-'], ['r', 'π'], ['s', '≠'], ['t', '+'],
        ['u', '_'], ['v', '∞'], ['w', '}'], ['x', '÷'], ['y', '√'],
        ['z', '?'], ['0', ')'], ['1', '!'], ['2', '^'], ['3', '@'],
        ['4', '&'], ['5', '#'], ['6', '*'], ['7', '$'], ['8', '('],
        ['9', '%']
      ];
      const specC = document.getElementById('special-keys');
      const kbC = document.getElementById('keyboard');

      specialKeys.forEach(type => {
        const btn = document.createElement('button');
        btn.className = 'key';
        btn.id = `key-${type}`; // Added ID for potential styling/selection
        // Use icons or shorter text if possible for vertical keys
        let btnText = type.charAt(0).toUpperCase() + type.slice(1);
        if (type === 'backspace') btnText = 'Bksp'; // Shorter text
        if (type === 'enter') btnText = 'Enter'; // Keep recognizable
        if (type === 'space') btnText = 'Spc'; // Shorter text

        btn.textContent = btnText;
        if (type === 'space') btn.dataset.main = ' '; // Store actual space character

        btn.addEventListener('click', (e) => {
          e.preventDefault(); // Prevent potential form submission if inside form
          if (type === 'backspace') {
            userInput.value = userInput.value.slice(0, -1);
          } else if (type === 'space') {
            userInput.value += ' ';
          } else if (type === 'enter') {
             // Trigger form submission programmatically
             inputForm.dispatchEvent(new Event('submit', { cancelable: true, bubbles: true }));
          }
           userInput.focus(); // Keep focus on input after key press
        });
        specC.appendChild(btn);
      });

      pairs.forEach(([main, alt]) => {
        const btn = document.createElement('button');
        btn.className = 'key';
        btn.textContent = `${main} ${alt}`; // Display both chars
        btn.dataset.main = main;
        btn.dataset.alt = alt;
        let pressTimer = null;
        let isLongPress = false;

        const startPress = (e) => {
            e.preventDefault(); // Prevent unwanted default actions (like text selection)
            isLongPress = false;
            clearTimeout(pressTimer); // Clear any existing timer
            pressTimer = setTimeout(() => {
                userInput.value += alt; // Insert alt char on long press
                userInput.focus();
                isLongPress = true;
                pressTimer = null; // Clear timer after execution
            }, 500); // 500ms threshold for long press
        };

        const endPress = (e) => {
            e.preventDefault();
            if (pressTimer) { // If timer is still running, it's a short press
                clearTimeout(pressTimer);
                pressTimer = null;
                if (!isLongPress) {
                    userInput.value += main; // Insert main char on short press
                    userInput.focus();
                }
            }
            // If isLongPress was true, action already happened in setTimeout
        };

        // Mouse events
        btn.addEventListener('mousedown', startPress);
        btn.addEventListener('mouseup', endPress);
        btn.addEventListener('mouseleave', () => { // Cancel timer if mouse leaves button
            if (pressTimer) {
                clearTimeout(pressTimer);
                pressTimer = null;
            }
        });

        // Touch events (ensure passive: false to allow preventDefault)
        btn.addEventListener('touchstart', startPress, { passive: false });
        btn.addEventListener('touchend', endPress);
        btn.addEventListener('touchcancel', () => { // Cancel timer if touch is cancelled
             if (pressTimer) {
                clearTimeout(pressTimer);
                pressTimer = null;
            }
        });

        kbC.appendChild(btn);
      });
    })();

    // --- Initialization ---
    async function initializeApp() {
        // Load API Key from localStorage
        const savedApiKey = localStorage.getItem('chatbot-api-key');
        if (savedApiKey) {
      
